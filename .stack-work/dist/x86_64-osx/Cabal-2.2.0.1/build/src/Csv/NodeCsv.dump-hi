
==================== FINAL INTERFACE ====================
2018-09-18 04:05:52.801377 UTC

interface research-0.1.0.0-j7VdR2I2YJJFJBbRfx0Cf:Csv.NodeCsv 8043
  interface hash: b82c9353e1e401b89831b406199920d2
  ABI hash: 0d244ca69877f4f8b02e6b7f29f50358
  export-list hash: 59726a1f16aa19b5e90d3091257628d3
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 86d0cc4c011855783eebbc036b2005f2
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Csv.NodeCsv.decodeNodeCsv
  Csv.NodeCsv.makeNodeCsv
  Csv.NodeCsv.Lat
  Csv.NodeCsv.Long
  Csv.NodeCsv.Node
  Csv.NodeCsv.NodeCsv
  Csv.NodeCsv.NodeCsvOut{Csv.NodeCsv.NodeCsvOut}
module dependencies:
package dependencies: Only-0.1 array-0.5.2.0 attoparsec-0.13.2.2
                      base-4.11.1.0 binary-0.8.5.1 bytestring-0.10.8.2 cassava-0.5.1.0
                      containers-0.5.11.0 deepseq-1.4.3.0 directory-1.3.1.5
                      filepath-1.4.2 ghc-prim-0.5.2.0 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 integer-logarithms-1.0.2.1 primitive-0.6.3.0
                      scientific-0.3.6.2 text-1.2.3.0 text-short-0.1.2 time-1.8.0.2
                      transformers-0.5.5.0 unix-2.7.2.2 unordered-containers-0.2.9.0
                      vector-0.12.0.1
orphans: vector-0.12.0.1:Data.Vector.Unboxed
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.0:Data.Text.Lazy
         text-1.2.3.0:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         transformers-0.5.5.0:Control.Monad.Trans.Error
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: Only-0.1:Data.Tuple.Only
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray text-1.2.3.0:Data.Text
                         text-1.2.3.0:Data.Text.Lazy
                         text-short-0.1.2:Data.Text.Short.Internal
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.IO 1d5542cc02075c5e948018bfacea89c1
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  bytestring-0.10.8.2:Data.ByteString.Lazy b6cb59a78204810b2a79502bf5b4c1fc
import  -/  cassava-0.5.1.0:Data.Csv e087d637255123ee2e7dd011b9101ca7
import  -/  cassava-0.5.1.0:Data.Csv.Conversion fa3155986f57c76f1fcf7fe125fe610c
import  -/  cassava-0.5.1.0:Data.Csv.Encoding e102678fedb1d8157053ef5b41c72291
import  -/  cassava-0.5.1.0:Data.Csv.Types 29bb03ee10947b382ef04279f6495f6c
import  -/  containers-0.5.11.0:Data.Map.Internal 0150e210d0ae8df0f3a0669d5e32d8fa
import  -/  containers-0.5.11.0:Data.Map.Strict 40ac55e8c7db7b7f0f7e3d9769233909
import  -/  containers-0.5.11.0:Data.Map.Strict.Internal 372117aaabc2f1ff2039eaf324fdb5c6
import  -/  directory-1.3.1.5:System.Directory bc76216f25ffcaf1c91b529f41ea3bf7
import  -/  directory-1.3.1.5:System.Directory.Internal.Common 88eeec2dd4e3d7d63bc24c2d657e6981
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  text-1.2.3.0:Data.Text 7daa7e6c9b39d8cc1679e5ec5c64d2be
import  -/  vector-0.12.0.1:Data.Vector a3a00743437ee8354b7b63f8638591df
6e070eb296f4ffc387bbe396b374f131
  $fFromNamedRecordNodeCsvOut ::
    Data.Csv.Conversion.FromNamedRecord Csv.NodeCsv.NodeCsvOut
  DFunId
  {- Arity: 1, Strictness: <L,U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Csv.NodeCsv.$fFromNamedRecordNodeCsvOut_$cparseNamedRecord
                  `cast`
                (Sym (Data.Csv.Conversion.N:FromNamedRecord[0]
                          <Csv.NodeCsv.NodeCsvOut>_N)) -}
6e070eb296f4ffc387bbe396b374f131
  $fFromNamedRecordNodeCsvOut_$cparseNamedRecord ::
    Data.Csv.Types.NamedRecord
    -> Data.Csv.Conversion.Parser Csv.NodeCsv.NodeCsvOut
  {- Arity: 1, Strictness: <L,U> -}
6e070eb296f4ffc387bbe396b374f131
  $fShowNodeCsvOut :: GHC.Show.Show Csv.NodeCsv.NodeCsvOut
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Csv.NodeCsv.NodeCsvOut
                  Csv.NodeCsv.$fShowNodeCsvOut_$cshowsPrec
                  Csv.NodeCsv.$fShowNodeCsvOut_$cshow
                  Csv.NodeCsv.$fShowNodeCsvOut_$cshowList -}
6e070eb296f4ffc387bbe396b374f131
  $fShowNodeCsvOut1 :: Csv.NodeCsv.NodeCsvOut -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U(U(U),1*U(U),1*U(U))>,
     Unfolding: (\ (w :: Csv.NodeCsv.NodeCsvOut) ->
                 case w of ww { Csv.NodeCsv.NodeCsvOut ww1 ww2 ww3 ->
                 Csv.NodeCsv.$w$cshowsPrec 0# ww1 ww2 ww3 }) -}
52cd2189331ace5604cc07e3a99aa469
  $fShowNodeCsvOut2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Csv.NodeCsv.$fShowNodeCsvOut3) -}
6be8946bd9d6b0156aad653d58bd6203
  $fShowNodeCsvOut3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("NodeCsvOut "#) -}
2dbda3852d9b2a7dc21ec411511c30f1
  $fShowNodeCsvOut4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
cfbc1e650c2a218c997fac7583fbd89f
  $fShowNodeCsvOut5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
6e070eb296f4ffc387bbe396b374f131
  $fShowNodeCsvOut_$cshow ::
    Csv.NodeCsv.NodeCsvOut -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U(U),1*U(U),1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Csv.NodeCsv.NodeCsvOut) ->
                 Csv.NodeCsv.$fShowNodeCsvOut_$cshowsPrec
                   Csv.NodeCsv.$fShowNodeCsvOut5
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
6e070eb296f4ffc387bbe396b374f131
  $fShowNodeCsvOut_$cshowList ::
    [Csv.NodeCsv.NodeCsvOut] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Csv.NodeCsv.NodeCsvOut]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Csv.NodeCsv.NodeCsvOut
                   Csv.NodeCsv.$fShowNodeCsvOut1
                   ls
                   s) -}
6e070eb296f4ffc387bbe396b374f131
  $fShowNodeCsvOut_$cshowsPrec ::
    GHC.Types.Int -> Csv.NodeCsv.NodeCsvOut -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(U(U),1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Csv.NodeCsv.NodeCsvOut) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Csv.NodeCsv.NodeCsvOut ww3 ww4 ww5 ->
                 Csv.NodeCsv.$w$cshowsPrec ww1 ww3 ww4 ww5 } }) -}
76953dc69958740b0e3ac111922c75c5
  $tc'NodeCsvOut :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2056653111126361736##
                   11258630924245015829##
                   Csv.NodeCsv.$trModule
                   Csv.NodeCsv.$tc'NodeCsvOut2
                   0#
                   Csv.NodeCsv.$tc'NodeCsvOut1) -}
f47bcc3eef7fc420954604710fe82394
  $tc'NodeCsvOut1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
9855f5ff6e80eb6789bb44ef0a5bee95
  $tc'NodeCsvOut2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Csv.NodeCsv.$tc'NodeCsvOut3) -}
61759fc703d072bd0d355048d9d0d5fa
  $tc'NodeCsvOut3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NodeCsvOut"#) -}
86d78fb4d996b57b722fea71bd15bb8c
  $tcNodeCsvOut :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17843343073787086096##
                   4731464128283102243##
                   Csv.NodeCsv.$trModule
                   Csv.NodeCsv.$tcNodeCsvOut1
                   0#
                   GHC.Types.krep$*) -}
24a317616db170662a83f14b13c75312
  $tcNodeCsvOut1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Csv.NodeCsv.$tcNodeCsvOut2) -}
a4c237c17d887232f4ae2ede83366f68
  $tcNodeCsvOut2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("NodeCsvOut"#) -}
a31e4a4721afc36bc9299cc7c4ad7252
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Csv.NodeCsv.$trModule3
                   Csv.NodeCsv.$trModule1) -}
21041c48cc7a6c8e0ca4736691acecda
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Csv.NodeCsv.$trModule2) -}
dd936d564d70e4bf96a48c779a647630
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Csv.NodeCsv"#) -}
6507509fbcafaffcdd810743a35f4c22
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Csv.NodeCsv.$trModule4) -}
a2472b555622b61cf67e7660e4b4a858
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("research-0.1.0.0-j7VdR2I2YJJFJBbRfx0Cf"#) -}
6a325e85f937f9d5775870d0abc7c1b5
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> Csv.NodeCsv.Node
    -> Csv.NodeCsv.Lat
    -> Csv.NodeCsv.Long
    -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <S,U><L,U(U)><L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: Csv.NodeCsv.Node)
                   (ww2 :: Csv.NodeCsv.Lat)
                   (ww3 :: Csv.NodeCsv.Long) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = case ww2 of ww4 { GHC.Types.D# ww5 ->
                     GHC.Float.$w$sshowSignedFloat
                       GHC.Float.$fShowDouble2
                       Csv.NodeCsv.$fShowNodeCsvOut4
                       ww5 }
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = case ww3 of ww4 { GHC.Types.D# ww5 ->
                     GHC.Float.$w$sshowSignedFloat
                       GHC.Float.$fShowDouble2
                       Csv.NodeCsv.$fShowNodeCsvOut4
                       ww5 }
                 } in
                 let {
                   g1 :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     case ww1 of ww4 { GHC.Types.I# ww5 ->
                     case GHC.Show.$wshowSignedInt
                            11#
                            ww5
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (f (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.showSpace1
                                     (g x)))) of ww6 { (#,#) ww7 ww8 ->
                     GHC.Types.: @ GHC.Types.Char ww7 ww8 } }
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Base.++ @ GHC.Types.Char Csv.NodeCsv.$fShowNodeCsvOut2 (g1 x)
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Csv.NodeCsv.$fShowNodeCsvOut2
                           (g1 (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }) -}
a4cc912e8e48173c60ec85a444f6c5ee
  $w$sgo8 ::
    GHC.Prim.Int#
    -> a1
    -> Data.Map.Internal.Map Csv.NodeCsv.Node a1
    -> Data.Map.Internal.Map Csv.NodeCsv.Node a1
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [0] -}
051cadb7081834fddebeae22508389f3
  $wmakeNodeCsv ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Array# Csv.NodeCsv.NodeCsvOut
    -> Data.Vector.Fusion.Util.Id
         (Data.Map.Internal.Map
            Csv.NodeCsv.Node (Csv.NodeCsv.Lat, Csv.NodeCsv.Long))
  {- Arity: 3, Strictness: <L,U><S,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Array# Csv.NodeCsv.NodeCsvOut) ->
                 letrec {
                   $wfoldrM_loop :: GHC.Types.SPEC
                                    -> GHC.Prim.Int#
                                    -> Data.Vector.Fusion.Util.Id
                                         (Data.Map.Internal.Map
                                            Csv.NodeCsv.Node (Csv.NodeCsv.Lat, Csv.NodeCsv.Long))
                     {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0] -}
                   = \ (w :: GHC.Types.SPEC) (ww3 :: GHC.Prim.Int#) ->
                     case w of ds5 { DEFAULT ->
                     case GHC.Prim.>=# ww3 ww1 of lwild {
                       DEFAULT
                       -> case GHC.Prim.indexArray#
                                 @ Csv.NodeCsv.NodeCsvOut
                                 ww2
                                 (GHC.Prim.+# ww ww3) of ds3 { Unit# ipv ->
                          case ipv of wild { Csv.NodeCsv.NodeCsvOut n lat long ->
                          case n of ww4 { GHC.Types.I# ww5 ->
                          (Csv.NodeCsv.$w$sgo8
                             @ (Csv.NodeCsv.Lat, Csv.NodeCsv.Long)
                             ww5
                             (lat, long)
                             ($wfoldrM_loop GHC.Types.SPEC (GHC.Prim.+# ww3 1#))
                               `cast`
                             (Data.Vector.Fusion.Util.N:Id[0]
                                  <Data.Map.Internal.Map
                                     Csv.NodeCsv.Node (Csv.NodeCsv.Lat, Csv.NodeCsv.Long)>_R))
                            `cast`
                          (Sym (Data.Vector.Fusion.Util.N:Id[0]
                                    <Data.Map.Internal.Map
                                       Csv.NodeCsv.Node
                                       (Csv.NodeCsv.Lat, Csv.NodeCsv.Long)>_R)) } } }
                       1#
                       -> (Data.Map.Internal.Tip
                             @ Csv.NodeCsv.Node
                             @ (Csv.NodeCsv.Lat, Csv.NodeCsv.Long))
                            `cast`
                          (Sym (Data.Vector.Fusion.Util.N:Id[0]
                                    <Data.Map.Internal.Map
                                       Csv.NodeCsv.Node (Csv.NodeCsv.Lat, Csv.NodeCsv.Long)>_R)) } }
                 } in
                 $wfoldrM_loop GHC.Types.SPEC 0#) -}
4dc8ad1c96bcbaf16125f622c34469e1
  type Lat = GHC.Types.Double
cffcd7a05fccae5aaf3f5a4dbd168e36
  type Long = GHC.Types.Double
ba16a05a11d3989fdf85ec5ef4311088
  type Node = GHC.Types.Int
2ffb6ceb0d0a0aa089df94bfdb3e3e99
  type NodeCsv =
    Data.Map.Internal.Map
      Csv.NodeCsv.Node (Csv.NodeCsv.Lat, Csv.NodeCsv.Long)
6e070eb296f4ffc387bbe396b374f131
  data NodeCsvOut
    = NodeCsvOut Csv.NodeCsv.Node Csv.NodeCsv.Lat Csv.NodeCsv.Long
3738a8ae70a606eb4762f83097c020f7
  decodeNodeCsv ::
    GHC.IO.FilePath -> GHC.Types.IO Csv.NodeCsv.NodeCsv
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Csv.NodeCsv.decodeNodeCsv1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Csv.NodeCsv.NodeCsv>_R)) -}
a11ddb28bf3171e8834786d9e82c1524
  decodeNodeCsv1 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Csv.NodeCsv.NodeCsv #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (fp :: GHC.IO.FilePath)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.IO.Error.modifyIOError1
                        @ GHC.IO.FilePath
                        System.Directory.Internal.Common.getCurrentDirectory6
                        System.Directory.Internal.Common.getCurrentDirectory2
                          `cast`
                        (Sym (GHC.Types.N:IO[0] <GHC.IO.FilePath>_R))
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.FD.openBinaryFile1
                        (GHC.Base.++
                           @ GHC.Types.Char
                           ipv1
                           (GHC.CString.unpackAppendCString# Csv.NodeCsv.decodeNodeCsv3 fp))
                        GHC.IO.IOMode.ReadMode
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case Data.ByteString.Lazy.getContents2
                        ipv3
                        ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                 (# ipv4,
                    case Data.Csv.Encoding.$wdecodeByNameWith
                           @ Csv.NodeCsv.NodeCsvOut
                           Csv.NodeCsv.$fFromNamedRecordNodeCsvOut_$cparseNamedRecord
                             `cast`
                           (Sym (Data.Csv.Conversion.N:FromNamedRecord[0]
                                     <Csv.NodeCsv.NodeCsvOut>_N))
                           44##
                           ipv5 of wild {
                      Data.Either.Left ipv6
                      -> case Csv.NodeCsv.decodeNodeCsv2 ret_ty Csv.NodeCsv.NodeCsv of {}
                      Data.Either.Right ds
                      -> case ds of wild1 { (,) ds4 ls ->
                         case ls of v2 { Data.Vector.Vector ipv6 ipv7 ipv8 ->
                         letrec {
                           $wfoldrM_loop :: GHC.Types.SPEC
                                            -> GHC.Prim.Int#
                                            -> Data.Vector.Fusion.Util.Id
                                                 (Data.Map.Internal.Map
                                                    Csv.NodeCsv.Node
                                                    (Csv.NodeCsv.Lat, Csv.NodeCsv.Long))
                             {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0] -}
                           = \ (w :: GHC.Types.SPEC) (ww :: GHC.Prim.Int#) ->
                             case w of ds5 { DEFAULT ->
                             case GHC.Prim.>=# ww ipv7 of lwild {
                               DEFAULT
                               -> case GHC.Prim.indexArray#
                                         @ Csv.NodeCsv.NodeCsvOut
                                         ipv8
                                         (GHC.Prim.+# ipv6 ww) of ds6 { Unit# ipv9 ->
                                  case ipv9 of wild2 { Csv.NodeCsv.NodeCsvOut n lat long ->
                                  case n of ww1 { GHC.Types.I# ww2 ->
                                  (Csv.NodeCsv.$w$sgo8
                                     @ (Csv.NodeCsv.Lat, Csv.NodeCsv.Long)
                                     ww2
                                     (lat, long)
                                     ($wfoldrM_loop GHC.Types.SPEC (GHC.Prim.+# ww 1#))
                                       `cast`
                                     (Data.Vector.Fusion.Util.N:Id[0]
                                          <Data.Map.Internal.Map
                                             Csv.NodeCsv.Node
                                             (Csv.NodeCsv.Lat, Csv.NodeCsv.Long)>_R))
                                    `cast`
                                  (Sym (Data.Vector.Fusion.Util.N:Id[0]
                                            <Data.Map.Internal.Map
                                               Csv.NodeCsv.Node
                                               (Csv.NodeCsv.Lat, Csv.NodeCsv.Long)>_R)) } } }
                               1#
                               -> (Data.Map.Internal.Tip
                                     @ Csv.NodeCsv.Node
                                     @ (Csv.NodeCsv.Lat, Csv.NodeCsv.Long))
                                    `cast`
                                  (Sym (Data.Vector.Fusion.Util.N:Id[0]
                                            <Data.Map.Internal.Map
                                               Csv.NodeCsv.Node
                                               (Csv.NodeCsv.Lat, Csv.NodeCsv.Long)>_R)) } }
                         } in
                         ($wfoldrM_loop GHC.Types.SPEC 0#)
                           `cast`
                         (Data.Vector.Fusion.Util.N:Id[0]
                              <Data.Map.Internal.Map
                                 Csv.NodeCsv.Node
                                 (Csv.NodeCsv.Lat, Csv.NodeCsv.Long)>_R) } } } #) } } }) -}
4dfdbf56cc3993edf7a6d7cdd82af765
  decodeNodeCsv2 :: (Data.Vector.Vector Csv.NodeCsv.NodeCsvOut)
  {- Strictness: x -}
ea9ab2a3dd54436d25c87afac03c773d
  decodeNodeCsv3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("/data/"#) -}
b4c92896fbf415b41b2d3fd594c1358e
  makeNodeCsv ::
    Data.Vector.Vector Csv.NodeCsv.NodeCsvOut -> Csv.NodeCsv.NodeCsv
  {- Arity: 1, Strictness: <S(SSS),1*U(U,U,U)>,
     Unfolding: InlineRule (0, True, True)
                Csv.NodeCsv.makeNodeCsv1
                  `cast`
                (<Data.Vector.Vector Csv.NodeCsv.NodeCsvOut>_R
                 ->_R Data.Vector.Fusion.Util.N:Id[0]
                          <Data.Map.Internal.Map
                             Csv.NodeCsv.Node (Csv.NodeCsv.Lat, Csv.NodeCsv.Long)>_R) -}
0f4d20093acf12c498e594e781a35e24
  makeNodeCsv1 ::
    Data.Vector.Vector Csv.NodeCsv.NodeCsvOut
    -> Data.Vector.Fusion.Util.Id
         (Data.Map.Internal.Map
            Csv.NodeCsv.Node (Csv.NodeCsv.Lat, Csv.NodeCsv.Long))
  {- Arity: 1, Strictness: <S(SSS),1*U(U,U,U)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Data.Vector.Vector Csv.NodeCsv.NodeCsvOut) ->
                 case w of ww { Data.Vector.Vector ww1 ww2 ww3 ->
                 Csv.NodeCsv.$wmakeNodeCsv ww1 ww2 ww3 }) -}
instance Data.Csv.Conversion.FromNamedRecord [Csv.NodeCsv.NodeCsvOut]
  = Csv.NodeCsv.$fFromNamedRecordNodeCsvOut
instance GHC.Show.Show [Csv.NodeCsv.NodeCsvOut]
  = Csv.NodeCsv.$fShowNodeCsvOut
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

