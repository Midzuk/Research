
==================== FINAL INTERFACE ====================
2018-09-15 08:03:06.3055794 UTC

interface research-0.1.0.0-j7VdR2I2YJJFJBbRfx0Cf:FrankWolfe 8043
  interface hash: 9eafe8c5359792738fe54b938d11af5e
  ABI hash: cc104347f1e0bbe832cc3c7b824d7fd6
  export-list hash: df2cfd328023378798a501c3cf94dc05
  orphan hash: 75ef60f9377b0741f2cb679f794f1004
  flag hash: 251996aa299c5fbc0c2a03dd0638dbbe
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  FrankWolfe.allOrNothing
  FrankWolfe.bpr
  FrankWolfe.diffLinkFlow
  FrankWolfe.frankWolfe
  FrankWolfe.makeLinkParameter
  FrankWolfe.makeNetwork
  FrankWolfe.sumTime
  FrankWolfe.Alpha
  FrankWolfe.Beta
  FrankWolfe.Capacity
  FrankWolfe.Flow
  FrankWolfe.LinkFlow
  FrankWolfe.LinkParameter
  FrankWolfe.Time
  FrankWolfe.Tolerance
  FrankWolfe.Trip
module dependencies: Dijkstra Search
package dependencies: array-0.5.2.0 base-4.11.1.0
                      containers-0.5.11.0 deepseq-1.4.3.0 ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0 primitive-0.6.3.0 transformers-0.5.5.0
                      vector-0.12.0.1
orphans: vector-0.12.0.1:Data.Vector.Fusion.Bundle
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Set.Internal
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array vector-0.12.0.1:Data.Vector
import  -/  base-4.11.1.0:Data.Foldable 6cf3e918f22d03c0870804f05cd183d1
import  -/  base-4.11.1.0:Debug.Trace a039f196c8a0dd416a8318b57f69c6b6
import  -/  base-4.11.1.0:GHC.Base b7dd14d8fe8d606dde5678ea6b0575e9
import  -/  base-4.11.1.0:GHC.Float 99ddb84df6cc12bd84829dd8cd755ac2
import  -/  base-4.11.1.0:GHC.Num 5de8df0185e7e8d8ec29b3c61e2c8606
import  -/  base-4.11.1.0:GHC.Real 032ed0a1053f878238d78e95e75f2edf
import  -/  base-4.11.1.0:Prelude aca391812f777207b15d62bb5b9feb63
import  -/  containers-0.5.11.0:Data.Map.Internal a2314ee57e16ff1fe3af08500b455e81
import  -/  containers-0.5.11.0:Data.Map.Strict ea9cec0dc7e4353594a3f7d520e82c83
import  -/  containers-0.5.11.0:Data.Map.Strict.Internal 9061dd54223c7e14ff6837ade55c2970
import  -/  containers-0.5.11.0:Data.Set eb0fbc743d474b13246bc4dbf4a83977
import  -/  ghc-prim-0.5.2.0:GHC.Classes f7d67fd97d5a20e9252c9597d1aa387b
import  -/  Dijkstra 5b4529a292efc43362de61a8e02f9544
  exports: b4be0d883e410f6b06a8eaf5eb4efc5f
  Edge f33d460aa892bc2dbea81fac9ebb671e
  Graph d436f672da20f47a2d710b0e1d4dd7db
  Link 638b0db170f5c23969f779171705a5d2
  Network c0b312afefccd42a9ce454b83de7322d
  OD 9f64ca6b98d4a23220a093e24fc16c6b
  shortestPath 7d5c15de61d8de0ff6d8213413fc8b08
import  -/  Search a8e09805c6cd5df397e59132d3360452
  exports: c0d473d2c208c69354ce97f9e6a6a9e7
  searchMin 590bb9a849a10e842225fc3470905432
import  -/  vector-0.12.0.1:Data.Vector 136e29dd913b307387c1c07459bacd27
49ac16be0d2bf1abba847727de9bbe70
  $sunionWith ::
    (a -> a -> a)
    -> Data.Map.Internal.Map Dijkstra.OD a
    -> Data.Map.Internal.Map Dijkstra.OD a
    -> Data.Map.Internal.Map Dijkstra.OD a
  {- Arity: 3, Strictness: <L,C(C1(U))><S,1*U><S,1*U>, Inline: [~] -}
b11659aa32b30de70078a72d6358a40e
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   FrankWolfe.$trModule3
                   FrankWolfe.$trModule1) -}
8d5ab9a16c7d63915a773161b0eb1f1e
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS FrankWolfe.$trModule2) -}
00a90df98937f01c31816cb21e321a00
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("FrankWolfe"#) -}
c2ab982a69a434e06411f3c7fe353d59
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS FrankWolfe.$trModule4) -}
e45f36c5f51bb38caf041db32cd26580
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("research-0.1.0.0-j7VdR2I2YJJFJBbRfx0Cf"#) -}
056cd64ef92ccba386da9562e990a6e5
  $w$sgo1 ::
    (a1 -> a1 -> a1)
    -> Dijkstra.Node
    -> Dijkstra.Node
    -> a1
    -> Data.Map.Internal.Map Dijkstra.OD a1
    -> Data.Map.Internal.Map Dijkstra.OD a1
  {- Arity: 5,
     Strictness: <L,1*C1(C1(U))><L,U(U)><L,U(U)><L,U><S,1*U>,
     Inline: [0] -}
caa63c7bbd31fedf0d87f953a8fe6938
  $w$sgo13 ::
    Dijkstra.Node
    -> Dijkstra.Node
    -> Data.Map.Internal.Map Dijkstra.OD a1
    -> (# Data.Map.Internal.Map Dijkstra.OD a1, GHC.Base.Maybe a1,
          Data.Map.Internal.Map Dijkstra.OD a1 #)
  {- Arity: 3, Strictness: <L,1*U(U)><L,U(U)><S,1*U>, Inline: [0] -}
cdec73672fdb2640c0aeb7452a92117f
  $w$sgo2 ::
    (a1 -> a1 -> a1)
    -> Dijkstra.Node
    -> Dijkstra.Node
    -> a1
    -> Data.Map.Internal.Map Dijkstra.OD a1
    -> Data.Map.Internal.Map Dijkstra.OD a1
  {- Arity: 5,
     Strictness: <L,1*C1(C1(U))><L,U(U)><L,U(U)><L,U><S,1*U>,
     Inline: [0] -}
c230bbe72390a82c3147b40b74a34b4d
  $w$sgo8 ::
    Dijkstra.Node
    -> Dijkstra.Node
    -> a1
    -> Data.Map.Internal.Map Dijkstra.OD a1
    -> Data.Map.Internal.Map Dijkstra.OD a1
  {- Arity: 4, Strictness: <L,U(U)><L,U(U)><S,1*U><S,1*U>,
     Inline: [0] -}
fad80467a2d64d5c275ccb81d9bbd6a4
  $wfrankWolfe ::
    GHC.Prim.Double#
    -> FrankWolfe.Trip
    -> FrankWolfe.LinkParameter
    -> Data.Map.Internal.Map Dijkstra.OD Search.X
  {- Arity: 3, Strictness: <S,U><S,U><L,U>, Inline: [0] -}
df12d894ccb136e6e3d0ffeb46e002ca
  $wpoly_go1 ::
    GHC.Prim.Int#
    -> Dijkstra.Node -> Data.Map.Internal.Map Dijkstra.OD a -> a
  {- Arity: 3, Strictness: <S,U><L,U(U)><S,1*U>, Inline: [0] -}
11373b64e5cefefa8bb505fdcfbc8201
  $wpoly_go13 ::
    GHC.Prim.Double#
    -> Data.Map.Internal.Map k FrankWolfe.Flow -> GHC.Prim.Double#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: [0] -}
c670da60d3b87514a3aa77a7b2b60c25
  $wsumTime ::
    FrankWolfe.LinkParameter -> FrankWolfe.LinkFlow -> GHC.Prim.Double#
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0],
     Unfolding: (\ (w :: FrankWolfe.LinkParameter)
                   (w1 :: FrankWolfe.LinkFlow) ->
                 letrec {
                   $wgo13 :: GHC.Prim.Double#
                             -> Data.Map.Internal.Map Dijkstra.OD FrankWolfe.Time
                             -> GHC.Prim.Double#
                     {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [0] -}
                   = \ (ww :: GHC.Prim.Double#)
                       (w2 :: Data.Map.Internal.Map Dijkstra.OD FrankWolfe.Time) ->
                     case w2 of wild {
                       Data.Map.Internal.Bin dt kx x l r
                       -> case kx of ww1 { Dijkstra.:->: ww2 ww3 ->
                          case $wgo13 ww r of ww4 { DEFAULT ->
                          case ww2 of ww5 { GHC.Types.I# ww6 ->
                          case FrankWolfe.$wpoly_go1
                                 @ (FrankWolfe.Time, FrankWolfe.Capacity, FrankWolfe.Alpha,
                                    FrankWolfe.Beta)
                                 ww6
                                 ww3
                                 w of wild1 { (,,,) t c a b ->
                          case t of wild2 { GHC.Types.D# x1 ->
                          case x of wild3 { GHC.Types.D# y ->
                          case a of wild4 { GHC.Types.D# x2 ->
                          case b of wild5 { GHC.Types.D# x3 ->
                          case GHC.Prim./## x2 (GHC.Prim.+## x3 1.0##) of wild6 { DEFAULT ->
                          case c of wild7 { GHC.Types.D# y1 ->
                          case GHC.Prim./## y y1 of wild8 { DEFAULT ->
                          $wgo13
                            (GHC.Prim.+##
                               ww4
                               (GHC.Prim.*##
                                  (GHC.Prim.*## x1 y)
                                  (GHC.Prim.+##
                                     1.0##
                                     (GHC.Prim.*## wild6 (GHC.Prim.**## wild8 x3)))))
                            l } } } } } } } } } } }
                       Data.Map.Internal.Tip -> ww }
                 } in
                 $wgo13 0.0## w1) -}
4e15e2d26940a12e9589f5133806f114
  type Alpha = GHC.Types.Double
c28453ef4b7754a6710ad8bc530d7eb4
  type Beta = GHC.Types.Double
c5b7ebe49d49938872025d00ab830ac8
  type Capacity = GHC.Types.Double
2cb1607a3589aff1606ce37ffa9fc7dd
  type Flow = GHC.Types.Double
15690b90b6881a40adf20bb7b2613dd1
  type LinkFlow = FrankWolfe.Trip
ce3729301d4554f1b5eae41a27ccc231
  type LinkParameter =
    Data.Map.Internal.Map
      Dijkstra.OD
      (FrankWolfe.Time, FrankWolfe.Capacity, FrankWolfe.Alpha,
       FrankWolfe.Beta)
58d8259f0c734ea2f00b609b608bde89
  type Time = GHC.Types.Double
81a5df1804e287f145816f8586291442
  type Tolerance = GHC.Types.Double
93371067eb07b6d21305d3a27cf5d932
  type Trip = Data.Map.Internal.Map Dijkstra.OD FrankWolfe.Flow
5e60c2c4c5c816928f204f8c1f241038
  allOrNothing ::
    FrankWolfe.Trip -> Dijkstra.Network -> FrankWolfe.LinkFlow
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ (t :: FrankWolfe.Trip) (n :: Dijkstra.Network) ->
                 let {
                   p :: Dijkstra.Path
                   = Dijkstra.shortestPath_go
                       n
                       (Data.Map.Internal.Tip @ Dijkstra.OD @ Dijkstra.Link)
                 } in
                 letrec {
                   go :: FrankWolfe.Trip -> FrankWolfe.LinkFlow -> FrankWolfe.LinkFlow
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: FrankWolfe.Trip) (lf :: FrankWolfe.LinkFlow) ->
                     case ds of wild {
                       Data.Map.Internal.Bin dt ds1 ds2 ds3 ds4
                       -> case Data.Map.Internal.minViewSure
                                 @ Dijkstra.OD
                                 @ FrankWolfe.Flow
                                 ds1
                                 ds2
                                 ds3
                                 ds4 of wild1 { Data.Map.Internal.MinView km xm t1 ->
                          case km of ww { Dijkstra.:->: ww1 ww2 ->
                          case ww1 of ww3 { GHC.Types.I# ww4 ->
                          case FrankWolfe.$wpoly_go1
                                 @ Dijkstra.Link
                                 ww4
                                 ww2
                                 p of wild2 { Dijkstra.Link ds7 ds8 ->
                          case ds7 of wild3 {
                            Dijkstra.Edge od
                            -> case od of ww5 { Dijkstra.:->: ww6 ww7 ->
                               go
                                 t1
                                 (FrankWolfe.$w$sgo1
                                    @ GHC.Types.Double
                                    GHC.Float.plusDouble
                                    ww6
                                    ww7
                                    xm
                                    lf) }
                            Dijkstra.Graph s
                            -> case s of v2 { Data.Vector.Vector ipv ipv1 ipv2 ->
                               letrec {
                                 $wfoldrM_loop :: GHC.Types.SPEC
                                                  -> GHC.Prim.Int#
                                                  -> Data.Vector.Fusion.Util.Id
                                                       (Data.Map.Internal.Map
                                                          Dijkstra.OD FrankWolfe.Flow)
                                   {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0] -}
                                 = \ (w :: GHC.Types.SPEC) (ww5 :: GHC.Prim.Int#) ->
                                   case w of ds5 { DEFAULT ->
                                   case GHC.Prim.>=# ww5 ipv1 of lwild {
                                     DEFAULT
                                     -> case GHC.Prim.indexArray#
                                               @ Dijkstra.OD
                                               ipv2
                                               (GHC.Prim.+# ipv ww5) of ds9 { Unit# ipv3 ->
                                        case ipv3 of ww6 { Dijkstra.:->: ww7 ww8 ->
                                        (FrankWolfe.$w$sgo1
                                           @ GHC.Types.Double
                                           GHC.Float.plusDouble
                                           ww7
                                           ww8
                                           xm
                                           ($wfoldrM_loop GHC.Types.SPEC (GHC.Prim.+# ww5 1#))
                                             `cast`
                                           (Data.Vector.Fusion.Util.N:Id[0]
                                                <Data.Map.Internal.Map
                                                   Dijkstra.OD FrankWolfe.Flow>_R))
                                          `cast`
                                        (Sym (Data.Vector.Fusion.Util.N:Id[0]
                                                  <Data.Map.Internal.Map
                                                     Dijkstra.OD FrankWolfe.Flow>_R)) } }
                                     1#
                                     -> lf
                                          `cast`
                                        (Sym (Data.Vector.Fusion.Util.N:Id[0]
                                                  <Data.Map.Internal.Map
                                                     Dijkstra.OD FrankWolfe.Flow>_R)) } }
                               } in
                               go
                                 t1
                                 ($wfoldrM_loop GHC.Types.SPEC 0#)
                                   `cast`
                                 (Data.Vector.Fusion.Util.N:Id[0]
                                      <Data.Map.Internal.Map
                                         Dijkstra.OD FrankWolfe.Flow>_R) } } } } } }
                       Data.Map.Internal.Tip -> lf }
                 } in
                 go t (Data.Map.Internal.Tip @ Dijkstra.OD @ FrankWolfe.Flow)) -}
879c6dd130e2734d58d32ecdc168d852
  bpr ::
    FrankWolfe.LinkParameter -> FrankWolfe.LinkFlow -> Dijkstra.Network
  {- Arity: 2, Strictness: <S,U><S,1*U>,
     Unfolding: (\ (lp :: FrankWolfe.LinkParameter)
                   (_lf :: FrankWolfe.LinkFlow) ->
                 letrec {
                   go :: Data.Map.Internal.Map Dijkstra.OD FrankWolfe.Capacity
                         -> Data.Map.Internal.Map Dijkstra.OD Dijkstra.Link
                         -> Data.Map.Internal.Map Dijkstra.OD Dijkstra.Link
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: Data.Map.Internal.Map Dijkstra.OD FrankWolfe.Capacity)
                       (n :: Data.Map.Internal.Map Dijkstra.OD Dijkstra.Link) ->
                     case ds of wild {
                       Data.Map.Internal.Bin dt ds1 ds2 ds3 ds4
                       -> case Data.Map.Internal.minViewSure
                                 @ Dijkstra.OD
                                 @ FrankWolfe.Capacity
                                 ds1
                                 ds2
                                 ds3
                                 ds4 of wild1 { Data.Map.Internal.MinView km xm t ->
                          case km of ww { Dijkstra.:->: ww1 ww2 ->
                          go
                            t
                            (FrankWolfe.$w$sgo8
                               @ Dijkstra.Link
                               ww1
                               ww2
                               (Dijkstra.Link
                                  (Dijkstra.Edge ww)
                                  (case ww1 of ww3 { GHC.Types.I# ww4 ->
                                   case FrankWolfe.$wpoly_go1
                                          @ (FrankWolfe.Time, FrankWolfe.Capacity, FrankWolfe.Alpha,
                                             FrankWolfe.Beta)
                                          ww4
                                          ww2
                                          lp of wild2 { (,,,) t1 c a b ->
                                   case t1 of wild3 { GHC.Types.D# x ->
                                   case a of wild4 { GHC.Types.D# x1 ->
                                   case xm of wild5 { GHC.Types.D# x2 ->
                                   case c of wild6 { GHC.Types.D# y ->
                                   case GHC.Prim./## x2 y of wild7 { DEFAULT ->
                                   case b of wild8 { GHC.Types.D# y1 ->
                                   GHC.Types.D#
                                     (GHC.Prim.*##
                                        x
                                        (GHC.Prim.+##
                                           1.0##
                                           (GHC.Prim.*##
                                              x1
                                              (GHC.Prim.**## wild7 y1)))) } } } } } } } }))
                               n) } }
                       Data.Map.Internal.Tip -> n }
                 } in
                 go
                   _lf
                   (Data.Map.Strict.Internal.mapWithKey
                      @ Dijkstra.OD
                      @ (Dijkstra.Cost, FrankWolfe.Capacity, FrankWolfe.Alpha,
                         FrankWolfe.Beta)
                      @ Dijkstra.Link
                      FrankWolfe.bpr1
                      lp)) -}
a69a27bd50e9db72ec88c7401db7a86f
  bpr1 ::
    Dijkstra.OD
    -> (Dijkstra.Cost, FrankWolfe.Capacity, FrankWolfe.Alpha,
        FrankWolfe.Beta)
    -> Dijkstra.Link
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(U,A,A,A)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (od :: Dijkstra.OD)
                   (ds :: (Dijkstra.Cost, FrankWolfe.Capacity, FrankWolfe.Alpha,
                           FrankWolfe.Beta)) ->
                 case ds of wild { (,,,) t c a b ->
                 Dijkstra.Link (Dijkstra.Edge od) t }) -}
8b67f02656e89c46363bd60d0af782fb
  diffLinkFlow ::
    FrankWolfe.LinkFlow -> FrankWolfe.LinkFlow -> FrankWolfe.LinkFlow
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (lf1 :: FrankWolfe.LinkFlow)
                   (lf2 :: FrankWolfe.LinkFlow) ->
                 FrankWolfe.$sunionWith
                   @ GHC.Types.Double
                   GHC.Float.plusDouble
                   lf1
                   (FrankWolfe.diffLinkFlow_go8 lf2)) -}
52da31e315b38a60310c51d448039421
  diffLinkFlow_go8 ::
    Data.Map.Internal.Map Dijkstra.OD FrankWolfe.Flow
    -> Data.Map.Internal.Map Dijkstra.OD FrankWolfe.Flow
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
e33a711fa633feb89ede5a2d8d0713d8
  frankWolfe ::
    FrankWolfe.Tolerance
    -> FrankWolfe.Trip
    -> FrankWolfe.LinkParameter
    -> FrankWolfe.LinkFlow
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,U><L,U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: FrankWolfe.Tolerance)
                   (w1 :: FrankWolfe.Trip)
                   (w2 :: FrankWolfe.LinkParameter) ->
                 case w of ww { GHC.Types.D# ww1 ->
                 FrankWolfe.$wfrankWolfe ww1 w1 w2 }) -}
f3f7250e5b2fccab5694a1e57b233128
  makeLinkParameter ::
    FrankWolfe.Capacity
    -> FrankWolfe.Alpha
    -> FrankWolfe.Beta
    -> Dijkstra.Network
    -> FrankWolfe.LinkParameter
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,U><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ (c :: FrankWolfe.Capacity)
                   (a :: FrankWolfe.Alpha)
                   (b :: FrankWolfe.Beta)
                   (eta :: Data.Map.Internal.Map Dijkstra.OD Dijkstra.Link) ->
                 Data.Map.Strict.Internal.mapWithKey
                   @ Dijkstra.OD
                   @ Dijkstra.Link
                   @ (Dijkstra.Cost, FrankWolfe.Capacity, FrankWolfe.Alpha,
                      FrankWolfe.Beta)
                   (\ (od :: Dijkstra.OD) (ds :: Dijkstra.Link)[OneShot] ->
                    case ds of wild { Dijkstra.Link ds1 t -> (t, c, a, b) })
                   eta) -}
b5cc3c7aca43a288be053cb314840436
  makeNetwork :: FrankWolfe.LinkParameter -> Dijkstra.Network
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (Data.Map.Strict.Internal.mapWithKey
                   @ Dijkstra.OD
                   @ (Dijkstra.Cost, FrankWolfe.Capacity, FrankWolfe.Alpha,
                      FrankWolfe.Beta)
                   @ Dijkstra.Link
                   FrankWolfe.bpr1) -}
a1d189f6c14096f39b5ae5900a856d83
  sumTime ::
    FrankWolfe.LinkParameter -> FrankWolfe.LinkFlow -> FrankWolfe.Time
  {- Arity: 2, Strictness: <L,U><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: FrankWolfe.LinkParameter) (w1 :: FrankWolfe.LinkFlow) ->
                 case FrankWolfe.$wsumTime w w1 of ww { DEFAULT ->
                 GHC.Types.D# ww }) -}
"SPEC/FrankWolfe unionWith @ OD _" [orphan] forall @ a
                                                   ($dOrd :: GHC.Classes.Ord Dijkstra.OD)
  Data.Map.Strict.Internal.unionWith @ Dijkstra.OD @ a $dOrd
  = FrankWolfe.$sunionWith @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

