
==================== FINAL INTERFACE ====================
2018-09-16 04:31:31.0203502 UTC

interface research-0.1.0.0-j7VdR2I2YJJFJBbRfx0Cf:CsvDecode.NodeCsvDecode 8043
  interface hash: 1d383f6bc9528228d05224b02d4fc41e
  ABI hash: 1a4489dac133f42ea92bbf07ebf0311f
  export-list hash: 3a3f70ed77dd91d84264b84b2049daf6
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: b5dfa34285e56b849576a82de3050450
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  CsvDecode.NodeCsvDecode.decodeNodeCsv
  CsvDecode.NodeCsvDecode.Node
  CsvDecode.NodeCsvDecode.NodeCsv{CsvDecode.NodeCsvDecode.NodeCsv}
  CsvDecode.NodeCsvDecode.X
  CsvDecode.NodeCsvDecode.Y
module dependencies:
package dependencies: Only-0.1 Win32-2.6.1.0 array-0.5.2.0
                      attoparsec-0.13.2.2 base-4.11.1.0 binary-0.8.5.1
                      bytestring-0.10.8.2 cassava-0.5.1.0 containers-0.5.11.0
                      deepseq-1.4.3.0 directory-1.3.1.5 filepath-1.4.2 ghc-prim-0.5.2.0
                      hashable-1.2.7.0 integer-gmp-1.0.2.0 integer-logarithms-1.0.2.1
                      primitive-0.6.3.0 scientific-0.3.6.2 text-1.2.3.0 text-short-0.1.2
                      time-1.8.0.2 transformers-0.5.5.0 unordered-containers-0.2.9.0
                      vector-0.12.0.1
orphans: vector-0.12.0.1:Data.Vector.Unboxed
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.0:Data.Text.Lazy
         text-1.2.3.0:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         transformers-0.5.5.0:Control.Monad.Trans.Error
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: Only-0.1:Data.Tuple.Only
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.11.1.0:Control.Applicative base-4.11.1.0:Data.Complex
                         base-4.11.1.0:Data.Functor.Compose base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray text-1.2.3.0:Data.Text
                         text-1.2.3.0:Data.Text.Lazy
                         text-short-0.1.2:Data.Text.Short.Internal
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.11.1.0:Data.Either 917cb7ca74324934e13727e32d71d117
import  -/  base-4.11.1.0:Data.Functor 920435f8ff93fffe1aec86c79e4fd45f
import  -/  base-4.11.1.0:Data.Maybe 1f53643457b97538ca6f4ca7328e8b30
import  -/  base-4.11.1.0:GHC.Base b7dd14d8fe8d606dde5678ea6b0575e9
import  -/  base-4.11.1.0:GHC.IO a3e5ac541c68a1abc106e1f0d10319a4
import  -/  base-4.11.1.0:GHC.Show 6211aec7cccd267a5ee999e4414d7b90
import  -/  base-4.11.1.0:Prelude aca391812f777207b15d62bb5b9feb63
import  -/  bytestring-0.10.8.2:Data.ByteString.Lazy 238696209da3e02ce3cd43ceb4046035
import  -/  cassava-0.5.1.0:Data.Csv 4a8a257da7b82acf18ea86eea1c587e8
import  -/  cassava-0.5.1.0:Data.Csv.Conversion da8ea50b3416c4f778aa71d7173c9b9a
import  -/  cassava-0.5.1.0:Data.Csv.Encoding cee893990c3de1dcaf70c384c5011766
import  -/  cassava-0.5.1.0:Data.Csv.Types 60e239de4036f80d78a883f7998c8d5b
import  -/  directory-1.3.1.5:System.Directory 4575206d001b0d3464a7b9287cf2e676
import  -/  directory-1.3.1.5:System.Directory.Internal.Common d74c803a65a464959a3007150832f056
import  -/  ghc-prim-0.5.2.0:GHC.Classes f7d67fd97d5a20e9252c9597d1aa387b
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  text-1.2.3.0:Data.Text c0e21f1d8acb5250a7f89b5dc0e8964e
import  -/  vector-0.12.0.1:Data.Vector 136e29dd913b307387c1c07459bacd27
bba32bb5d81e48bb6d5fcdbb91ac5b56
  $fFromNamedRecordNodeCsv ::
    Data.Csv.Conversion.FromNamedRecord CsvDecode.NodeCsvDecode.NodeCsv
  DFunId
  {- Arity: 1, Strictness: <L,U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                CsvDecode.NodeCsvDecode.$fFromNamedRecordNodeCsv_$cparseNamedRecord
                  `cast`
                (Sym (Data.Csv.Conversion.N:FromNamedRecord[0]
                          <CsvDecode.NodeCsvDecode.NodeCsv>_N)) -}
bba32bb5d81e48bb6d5fcdbb91ac5b56
  $fFromNamedRecordNodeCsv_$cparseNamedRecord ::
    Data.Csv.Types.NamedRecord
    -> Data.Csv.Conversion.Parser CsvDecode.NodeCsvDecode.NodeCsv
  {- Arity: 1, Strictness: <L,U> -}
bba32bb5d81e48bb6d5fcdbb91ac5b56
  $fShowNodeCsv :: GHC.Show.Show CsvDecode.NodeCsvDecode.NodeCsv
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ CsvDecode.NodeCsvDecode.NodeCsv
                  CsvDecode.NodeCsvDecode.$fShowNodeCsv_$cshowsPrec
                  CsvDecode.NodeCsvDecode.$fShowNodeCsv_$cshow
                  CsvDecode.NodeCsvDecode.$fShowNodeCsv_$cshowList -}
bba32bb5d81e48bb6d5fcdbb91ac5b56
  $fShowNodeCsv1 :: CsvDecode.NodeCsvDecode.NodeCsv -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U(U(U),1*U(U),1*U(U))>,
     Unfolding: (\ (w :: CsvDecode.NodeCsvDecode.NodeCsv) ->
                 case w of ww { CsvDecode.NodeCsvDecode.NodeCsv ww1 ww2 ww3 ->
                 CsvDecode.NodeCsvDecode.$w$cshowsPrec 0# ww1 ww2 ww3 }) -}
4eea5378605d01c06b6f53d1c4a14ea7
  $fShowNodeCsv2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   CsvDecode.NodeCsvDecode.$fShowNodeCsv3) -}
1d688cd240a0258f86d1a760b9dada9d
  $fShowNodeCsv3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("NodeCsv "#) -}
e7aef7f3482a02338255b54fa9a89607
  $fShowNodeCsv4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
1ebaf0ce438b1323311f46451179cbaa
  $fShowNodeCsv5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
bba32bb5d81e48bb6d5fcdbb91ac5b56
  $fShowNodeCsv_$cshow ::
    CsvDecode.NodeCsvDecode.NodeCsv -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U(U),1*U(U),1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: CsvDecode.NodeCsvDecode.NodeCsv) ->
                 CsvDecode.NodeCsvDecode.$fShowNodeCsv_$cshowsPrec
                   CsvDecode.NodeCsvDecode.$fShowNodeCsv5
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
bba32bb5d81e48bb6d5fcdbb91ac5b56
  $fShowNodeCsv_$cshowList ::
    [CsvDecode.NodeCsvDecode.NodeCsv] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [CsvDecode.NodeCsvDecode.NodeCsv])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ CsvDecode.NodeCsvDecode.NodeCsv
                   CsvDecode.NodeCsvDecode.$fShowNodeCsv1
                   ls
                   s) -}
bba32bb5d81e48bb6d5fcdbb91ac5b56
  $fShowNodeCsv_$cshowsPrec ::
    GHC.Types.Int -> CsvDecode.NodeCsvDecode.NodeCsv -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(U(U),1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: CsvDecode.NodeCsvDecode.NodeCsv) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { CsvDecode.NodeCsvDecode.NodeCsv ww3 ww4 ww5 ->
                 CsvDecode.NodeCsvDecode.$w$cshowsPrec ww1 ww3 ww4 ww5 } }) -}
e63543edfda11da3436e1ce7fb1a131c
  $tc'NodeCsv :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14850825439490598426##
                   16550640505631443231##
                   CsvDecode.NodeCsvDecode.$trModule
                   CsvDecode.NodeCsvDecode.$tc'NodeCsv2
                   0#
                   CsvDecode.NodeCsvDecode.$tc'NodeCsv1) -}
d49f26e84e2b59c775eab44738e247a8
  $tc'NodeCsv1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ef094b48768599948e34b5703013897f
  $tc'NodeCsv2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   CsvDecode.NodeCsvDecode.$tc'NodeCsv3) -}
131bba857a7a4080aedd079b9dc4ef45
  $tc'NodeCsv3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NodeCsv"#) -}
f3c791af71287de6eab9e6ecb895ddc4
  $tcNodeCsv :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14772884274287706596##
                   6113464536186487480##
                   CsvDecode.NodeCsvDecode.$trModule
                   CsvDecode.NodeCsvDecode.$tcNodeCsv1
                   0#
                   GHC.Types.krep$*) -}
72ea010a3e7abd31d7a9832ab78d5611
  $tcNodeCsv1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   CsvDecode.NodeCsvDecode.$tcNodeCsv2) -}
1baef17a0460a7ed736bb58beaf871c2
  $tcNodeCsv2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("NodeCsv"#) -}
6a3ec537f01a275ee2a85d8669940af0
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   CsvDecode.NodeCsvDecode.$trModule3
                   CsvDecode.NodeCsvDecode.$trModule1) -}
da2a0d99b2d7e0ea6f4a98d6ba3efcb7
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   CsvDecode.NodeCsvDecode.$trModule2) -}
42df3461e948a4fba9be1a30d3beb999
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("CsvDecode.NodeCsvDecode"#) -}
591d499182f1f6a62be17704d639e9ac
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   CsvDecode.NodeCsvDecode.$trModule4) -}
79aca057a6c23fc0f8e82afb6329dc4b
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("research-0.1.0.0-j7VdR2I2YJJFJBbRfx0Cf"#) -}
fb818420ca160b8ce13000fe8f73cd0b
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> CsvDecode.NodeCsvDecode.Node
    -> CsvDecode.NodeCsvDecode.X
    -> CsvDecode.NodeCsvDecode.Y
    -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <S,U><L,U(U)><L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: CsvDecode.NodeCsvDecode.Node)
                   (ww2 :: CsvDecode.NodeCsvDecode.X)
                   (ww3 :: CsvDecode.NodeCsvDecode.Y) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = case ww2 of ww4 { GHC.Types.D# ww5 ->
                     GHC.Float.$w$sshowSignedFloat
                       GHC.Float.$fShowDouble2
                       CsvDecode.NodeCsvDecode.$fShowNodeCsv4
                       ww5 }
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = case ww3 of ww4 { GHC.Types.D# ww5 ->
                     GHC.Float.$w$sshowSignedFloat
                       GHC.Float.$fShowDouble2
                       CsvDecode.NodeCsvDecode.$fShowNodeCsv4
                       ww5 }
                 } in
                 let {
                   g1 :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     case ww1 of ww4 { GHC.Types.I# ww5 ->
                     case GHC.Show.$wshowSignedInt
                            11#
                            ww5
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (f (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.showSpace1
                                     (g x)))) of ww6 { (#,#) ww7 ww8 ->
                     GHC.Types.: @ GHC.Types.Char ww7 ww8 } }
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Base.++
                        @ GHC.Types.Char
                        CsvDecode.NodeCsvDecode.$fShowNodeCsv2
                        (g1 x)
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.Base.++
                           @ GHC.Types.Char
                           CsvDecode.NodeCsvDecode.$fShowNodeCsv2
                           (g1 (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }) -}
098e843d2e844cdcc910f72a48fc9393
  type Node = GHC.Types.Int
bba32bb5d81e48bb6d5fcdbb91ac5b56
  data NodeCsv
    = NodeCsv CsvDecode.NodeCsvDecode.Node
              CsvDecode.NodeCsvDecode.X
              CsvDecode.NodeCsvDecode.Y
1eb5cd5fa8fbfab53113bad613a4bad5
  type X = GHC.Types.Double
edb332fc55505897761891d4f941f11f
  type Y = GHC.Types.Double
cd9539d2ab7f7bbbd6ea7daec3315ac0
  decodeNodeCsv ::
    GHC.IO.FilePath
    -> GHC.Types.IO
         (Data.Vector.Vector CsvDecode.NodeCsvDecode.NodeCsv)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                CsvDecode.NodeCsvDecode.decodeNodeCsv1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <Data.Vector.Vector CsvDecode.NodeCsvDecode.NodeCsv>_R)) -}
04da44b9b24a780c863dbf2098770a5e
  decodeNodeCsv1 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Vector.Vector CsvDecode.NodeCsvDecode.NodeCsv #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (fp :: GHC.IO.FilePath)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.IO.Error.modifyIOError1
                        @ GHC.Base.String
                        System.Directory.Internal.Common.getCurrentDirectory6
                        System.Directory.Internal.Common.getCurrentDirectory2
                          `cast`
                        (Sym (GHC.Types.N:IO[0] <GHC.Base.String>_R))
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.FD.openBinaryFile1
                        (GHC.Base.++
                           @ GHC.Types.Char
                           ipv1
                           (GHC.CString.unpackAppendCString#
                              CsvDecode.NodeCsvDecode.decodeNodeCsv3
                              fp))
                        GHC.IO.IOMode.ReadMode
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case Data.ByteString.Lazy.getContents2
                        ipv3
                        ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                 (# ipv4,
                    case Data.Csv.Encoding.$wdecodeByNameWith
                           @ CsvDecode.NodeCsvDecode.NodeCsv
                           CsvDecode.NodeCsvDecode.$fFromNamedRecordNodeCsv_$cparseNamedRecord
                             `cast`
                           (Sym (Data.Csv.Conversion.N:FromNamedRecord[0]
                                     <CsvDecode.NodeCsvDecode.NodeCsv>_N))
                           44##
                           ipv5 of wild {
                      Data.Either.Left ipv6
                      -> case CsvDecode.NodeCsvDecode.decodeNodeCsv2
                         ret_ty (Data.Vector.Vector CsvDecode.NodeCsvDecode.NodeCsv)
                         of {}
                      Data.Either.Right ds
                      -> case ds of wild1 { (,) ds4 ls -> ls } } #) } } }) -}
6db12cab271d24a88ba5c8b78ded0bcf
  decodeNodeCsv2 ::
    (Data.Vector.Vector CsvDecode.NodeCsvDecode.NodeCsv)
  {- Strictness: x -}
3b7cb8891625168562c57d23831e3830
  decodeNodeCsv3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("/data/"#) -}
instance Data.Csv.Conversion.FromNamedRecord [CsvDecode.NodeCsvDecode.NodeCsv]
  = CsvDecode.NodeCsvDecode.$fFromNamedRecordNodeCsv
instance GHC.Show.Show [CsvDecode.NodeCsvDecode.NodeCsv]
  = CsvDecode.NodeCsvDecode.$fShowNodeCsv
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

